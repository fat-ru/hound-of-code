package api

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"strings"

	"github.com/hound-search/hound/data"
)

// CreateRepoConfigRequest represents a request to create a repo config
type CreateRepoConfigRequest struct {
	Name               string `json:"name"`
	URL                string `json:"url"`
	Branch             string `json:"branch"`
	VcsType            string `json:"vcsType"`
	DisplayName        string `json:"displayName"`
	Enabled            bool   `json:"enabled"`
	MsBetweenPolls     int    `json:"msBetweenPolls"`
	VcsConfig          string `json:"vcsConfig"`
	ExcludeDotFiles    bool   `json:"excludeDotFiles"`
	EnablePollUpdates  bool   `json:"enablePollUpdates"`
	EnablePushUpdates  bool   `json:"enablePushUpdates"`
	AutoGeneratedFiles string `json:"autoGeneratedFiles"`
}

// UpdateRepoConfigRequest represents a request to update a repo config
type UpdateRepoConfigRequest struct {
	Name               string `json:"name"`
	URL                string `json:"url"`
	Branch             string `json:"branch"`
	VcsType            string `json:"vcsType"`
	DisplayName        string `json:"displayName"`
	Enabled            bool   `json:"enabled"`
	MsBetweenPolls     int    `json:"msBetweenPolls"`
	VcsConfig          string `json:"vcsConfig"`
	ExcludeDotFiles    bool   `json:"excludeDotFiles"`
	EnablePollUpdates  bool   `json:"enablePollUpdates"`
	EnablePushUpdates  bool   `json:"enablePushUpdates"`
	AutoGeneratedFiles string `json:"autoGeneratedFiles"`
}

// RepoConfigListResponse represents a list of repo configs
type RepoConfigListResponse struct {
	RepoConfigs []*data.RepoConfig `json:"repoConfigs"`
	TotalCount  int                `json:"totalCount"`
}

// SetupRepoConfig configures repository configuration API routes
func SetupRepoConfig(m *http.ServeMux) {
	m.HandleFunc("/api/v1/repos/config", HandleRepoConfigs)
}

// HandleRepoConfigs handles GET/POST for repo configs
func HandleRepoConfigs(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		HandleGetRepoConfigs(w, r)
	case http.MethodPost:
		HandleCreateRepoConfig(w, r)
	default:
		writeError(w, errors.New("method not allowed"), http.StatusMethodNotAllowed)
	}
}

// HandleGetRepoConfigs handles GET /api/v1/repos/config
func HandleGetRepoConfigs(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query().Get("q")
	var configs []*data.RepoConfig
	var err error

	if query != "" {
		configs, err = data.SearchRepoConfigs(query)
	} else {
		configs, err = data.GetAllRepoConfigs()
	}

	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}

	writeResp(w, &RepoConfigListResponse{
		RepoConfigs: configs,
		TotalCount:  len(configs),
	})
}

// HandleCreateRepoConfig handles POST /api/v1/repos/config
func HandleCreateRepoConfig(w http.ResponseWriter, r *http.Request) {
	var req CreateRepoConfigRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, errors.New("invalid request body"), http.StatusBadRequest)
		return
	}

	// Validate input
	if strings.TrimSpace(req.Name) == "" {
		writeError(w, errors.New("name is required"), http.StatusBadRequest)
		return
	}
	if strings.TrimSpace(req.URL) == "" {
		writeError(w, errors.New("URL is required"), http.StatusBadRequest)
		return
	}

	// Validate name (alphanumeric, dash, underscore)
	for _, c := range req.Name {
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '_') {
			writeError(w, errors.New("name must contain only alphanumeric characters, dashes, and underscores"), http.StatusBadRequest)
			return
		}
	}

	// Check if config exists
	existingConfig, err := data.GetRepoConfigByName(req.Name)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}
	if existingConfig != nil {
		writeError(w, errors.New("repository name already exists"), http.StatusConflict)
		return
	}

	// Set defaults
	branch := req.Branch
	if branch == "" {
		branch = "main"
	}

	vcsType := req.VcsType
	if vcsType == "" {
		vcsType = "git"
	}

	msBetweenPolls := req.MsBetweenPolls
	if msBetweenPolls == 0 {
		msBetweenPolls = 30000
	}

	// Create config
	config := &data.RepoConfig{
		Name:               req.Name,
		URL:                req.URL,
		Branch:             branch,
		VcsType:            vcsType,
		DisplayName:        req.DisplayName,
		Enabled:            req.Enabled,
		MsBetweenPolls:     msBetweenPolls,
		VcsConfig:          req.VcsConfig,
		ExcludeDotFiles:    req.ExcludeDotFiles,
		EnablePollUpdates:  req.EnablePollUpdates,
		EnablePushUpdates:  req.EnablePushUpdates,
		AutoGeneratedFiles: req.AutoGeneratedFiles,
	}

	created, err := data.CreateRepoConfig(config)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}

	// Create a searcher for the new repo and start indexing
	if req.Enabled {
		go func() {
			_, err := CreateSearcherForRepo(req.Name, created)
			if err != nil {
				log.Printf("Failed to create searcher for repo %s: %v", req.Name, err)
			}
		}()
	}

	writeResp(w, created)
}

// HandleGetRepoConfigByID handles GET /api/v1/repos/config/:id
func HandleGetRepoConfigByID(w http.ResponseWriter, r *http.Request) {
	id, err := ParseRepoConfigID(r.URL.Path)
	if err != nil {
		writeError(w, err, http.StatusBadRequest)
		return
	}

	config, err := data.GetRepoConfigByID(id)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}
	if config == nil {
		writeError(w, errors.New("repository configuration not found"), http.StatusNotFound)
		return
	}

	writeResp(w, config)
}

// HandleUpdateRepoConfig handles PUT /api/v1/repos/config/:id
func HandleUpdateRepoConfig(w http.ResponseWriter, r *http.Request) {
	id, err := ParseRepoConfigID(r.URL.Path)
	if err != nil {
		writeError(w, err, http.StatusBadRequest)
		return
	}

	var req UpdateRepoConfigRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeError(w, errors.New("invalid request body"), http.StatusBadRequest)
		return
	}

	// Get existing config
	existingConfig, err := data.GetRepoConfigByID(id)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}
	if existingConfig == nil {
		writeError(w, errors.New("repository configuration not found"), http.StatusNotFound)
		return
	}

	// Validate name if changed
	if req.Name != "" && req.Name != existingConfig.Name {
		for _, c := range req.Name {
			if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '_') {
				writeError(w, errors.New("name must contain only alphanumeric characters, dashes, and underscores"), http.StatusBadRequest)
				return
			}
		}

		// Check if new name already exists
		otherConfig, err := data.GetRepoConfigByName(req.Name)
		if err != nil {
			writeError(w, err, http.StatusInternalServerError)
			return
		}
		if otherConfig != nil {
			writeError(w, errors.New("repository name already exists"), http.StatusConflict)
			return
		}
	}

	// Update fields
	name := req.Name
	url := req.URL
	branch := req.Branch
	vcsType := req.VcsType

	if name == "" {
		name = existingConfig.Name
	}
	if url == "" {
		url = existingConfig.URL
	}
	if branch == "" {
		branch = existingConfig.Branch
	}
	if vcsType == "" {
		vcsType = existingConfig.VcsType
	}

	// Create updated config
	config := &data.RepoConfig{
		Name:               name,
		URL:                url,
		Branch:             branch,
		VcsType:            vcsType,
		DisplayName:        req.DisplayName,
		Enabled:            req.Enabled,
		MsBetweenPolls:     req.MsBetweenPolls,
		VcsConfig:          req.VcsConfig,
		ExcludeDotFiles:    req.ExcludeDotFiles,
		EnablePollUpdates:  req.EnablePollUpdates,
		EnablePushUpdates:  req.EnablePushUpdates,
		AutoGeneratedFiles: req.AutoGeneratedFiles,
	}

	// Preserve existing values for empty fields
	if config.DisplayName == "" {
		config.DisplayName = existingConfig.DisplayName
	}
	if config.MsBetweenPolls == 0 {
		config.MsBetweenPolls = existingConfig.MsBetweenPolls
	}
	if config.VcsConfig == "" {
		config.VcsConfig = existingConfig.VcsConfig
	}
	if config.AutoGeneratedFiles == "" {
		config.AutoGeneratedFiles = existingConfig.AutoGeneratedFiles
	}

	updated, err := data.UpdateRepoConfig(id, config)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}

	writeResp(w, updated)
}

// HandleDeleteRepoConfig handles DELETE /api/v1/repos/config/:id
func HandleDeleteRepoConfig(w http.ResponseWriter, r *http.Request) {
	id, err := ParseRepoConfigID(r.URL.Path)
	if err != nil {
		writeError(w, err, http.StatusBadRequest)
		return
	}

	// Check if config exists
	existingConfig, err := data.GetRepoConfigByID(id)
	if err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}
	if existingConfig == nil {
		writeError(w, errors.New("repository configuration not found"), http.StatusNotFound)
		return
	}

	// Delete config
	if err := data.DeleteRepoConfig(id); err != nil {
		writeError(w, err, http.StatusInternalServerError)
		return
	}

	writeResp(w, map[string]string{
		"message": "repository configuration deleted successfully",
	})
}

// ParseRepoConfigID extracts repo config ID from path
func ParseRepoConfigID(path string) (int64, error) {
	parts := strings.Split(path, "/")
	if len(parts) < 1 {
		return 0, errors.New("invalid path")
	}

	lastPart := parts[len(parts)-1]
	var id int64
	for _, c := range lastPart {
		if c < '0' || c > '9' {
			return 0, errors.New("invalid repository config ID")
		}
		id = id*10 + int64(c-'0')
	}
	return id, nil
}
