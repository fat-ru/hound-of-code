package api

import (
	"encoding/json"
	"log"
	"sync"

	"github.com/hound-search/hound/config"
	"github.com/hound-search/hound/data"
	"github.com/hound-search/hound/searcher"
)

// SearcherManager manages the searcher index map and provides thread-safe access
var SearcherManager struct {
	sync.RWMutex
	Indexers map[string]*searcher.Searcher
}

// AppConfig holds the application configuration
var AppConfig struct {
	DbPath string
}

// InitSearcherManager initializes the searcher manager
func InitSearcherManager(idx map[string]*searcher.Searcher, dbPath string) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	SearcherManager.Indexers = idx
	AppConfig.DbPath = dbPath
}

// AddSearcher adds a new searcher to the index
func AddSearcher(name string, s *searcher.Searcher) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	if SearcherManager.Indexers == nil {
		SearcherManager.Indexers = make(map[string]*searcher.Searcher)
	}
	SearcherManager.Indexers[name] = s
}

// RemoveSearcher removes a searcher from the index
func RemoveSearcher(name string) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	if SearcherManager.Indexers != nil {
		delete(SearcherManager.Indexers, name)
	}
}

// GetSearcher gets a searcher by name
func GetSearcher(name string) *searcher.Searcher {
	SearcherManager.RLock()
	defer SearcherManager.RUnlock()
	if SearcherManager.Indexers == nil {
		return nil
	}
	return SearcherManager.Indexers[name]
}

// GetAllSearchers returns a copy of all searchers
func GetAllSearchers() map[string]*searcher.Searcher {
	SearcherManager.RLock()
	defer SearcherManager.RUnlock()
	if SearcherManager.Indexers == nil {
		return make(map[string]*searcher.Searcher)
	}
	// Return a copy to prevent external modification
	result := make(map[string]*searcher.Searcher)
	for k, v := range SearcherManager.Indexers {
		result[k] = v
	}
	return result
}

// CreateSearcherForRepo creates a new searcher for a repository configuration
func CreateSearcherForRepo(name string, repoConfig *data.RepoConfig) (*searcher.Searcher, error) {
	if AppConfig.DbPath == "" {
		return nil, nil
	}

	// Convert data.RepoConfig to config.Repo
	repo := &config.Repo{
		Url:               repoConfig.URL,
		DisplayName:       repoConfig.DisplayName,
		MsBetweenPolls:    repoConfig.MsBetweenPolls,
		Vcs:               repoConfig.VcsType,
		ExcludeDotFiles:   repoConfig.ExcludeDotFiles,
		EnablePollUpdates: &repoConfig.EnablePollUpdates,
		EnablePushUpdates: &repoConfig.EnablePushUpdates,
	}

	// Build vcs-config with ref (branch) support
	vcsConfig := make(map[string]interface{})
	if repoConfig.VcsConfig != "" {
		if err := json.Unmarshal([]byte(repoConfig.VcsConfig), &vcsConfig); err != nil {
			log.Printf("Failed to parse vcs-config for repo %s: %v", name, err)
		}
	}

	// Add ref (branch) to vcs-config if specified and not already set
	// Always set ref if branch is specified, to override the default "master"
	if repoConfig.Branch != "" {
		if _, exists := vcsConfig["ref"]; !exists {
			vcsConfig["ref"] = repoConfig.Branch
		}
	}

	if len(vcsConfig) > 0 {
		msgBytes, _ := json.Marshal(vcsConfig)
		msg := json.RawMessage(msgBytes)
		repo.VcsConfigMessage = (*config.SecretMessage)(&msg)
	}

	if repoConfig.AutoGeneratedFiles != "" {
		var files []string
		if err := json.Unmarshal([]byte(repoConfig.AutoGeneratedFiles), &files); err == nil {
			repo.AutoGeneratedFiles = files
		}
	}

	s, err := searcher.New(AppConfig.DbPath, name, repo)
	if err != nil {
		return nil, err
	}

	AddSearcher(name, s)
	return s, nil
}
