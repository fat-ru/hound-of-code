package api

import (
	"encoding/json"
	"sync"

	"github.com/hound-search/hound/config"
	"github.com/hound-search/hound/data"
	"github.com/hound-search/hound/searcher"
)

// SearcherManager manages the searcher index map and provides thread-safe access
var SearcherManager struct {
	sync.RWMutex
	Indexers map[string]*searcher.Searcher
}

// AppConfig holds the application configuration
var AppConfig struct {
	DbPath string
}

// InitSearcherManager initializes the searcher manager
func InitSearcherManager(idx map[string]*searcher.Searcher, dbPath string) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	SearcherManager.Indexers = idx
	AppConfig.DbPath = dbPath
}

// AddSearcher adds a new searcher to the index
func AddSearcher(name string, s *searcher.Searcher) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	if SearcherManager.Indexers == nil {
		SearcherManager.Indexers = make(map[string]*searcher.Searcher)
	}
	SearcherManager.Indexers[name] = s
}

// RemoveSearcher removes a searcher from the index
func RemoveSearcher(name string) {
	SearcherManager.Lock()
	defer SearcherManager.Unlock()
	if SearcherManager.Indexers != nil {
		delete(SearcherManager.Indexers, name)
	}
}

// GetSearcher gets a searcher by name
func GetSearcher(name string) *searcher.Searcher {
	SearcherManager.RLock()
	defer SearcherManager.RUnlock()
	if SearcherManager.Indexers == nil {
		return nil
	}
	return SearcherManager.Indexers[name]
}

// GetAllSearchers returns a copy of all searchers
func GetAllSearchers() map[string]*searcher.Searcher {
	SearcherManager.RLock()
	defer SearcherManager.RUnlock()
	if SearcherManager.Indexers == nil {
		return make(map[string]*searcher.Searcher)
	}
	// Return a copy to prevent external modification
	result := make(map[string]*searcher.Searcher)
	for k, v := range SearcherManager.Indexers {
		result[k] = v
	}
	return result
}

// CreateSearcherForRepo creates a new searcher for a repository configuration
func CreateSearcherForRepo(name string, repoConfig *data.RepoConfig) (*searcher.Searcher, error) {
	if AppConfig.DbPath == "" {
		return nil, nil
	}

	// Convert data.RepoConfig to config.Repo
	repo := &config.Repo{
		Url:               repoConfig.URL,
		DisplayName:       repoConfig.DisplayName,
		MsBetweenPolls:    repoConfig.MsBetweenPolls,
		Vcs:               repoConfig.VcsType,
		ExcludeDotFiles:   repoConfig.ExcludeDotFiles,
		EnablePollUpdates: &repoConfig.EnablePollUpdates,
		EnablePushUpdates: &repoConfig.EnablePushUpdates,
	}

	if repoConfig.VcsConfig != "" {
		var vcsConfig map[string]interface{}
		if err := json.Unmarshal([]byte(repoConfig.VcsConfig), &vcsConfig); err == nil {
			msg := json.RawMessage(repoConfig.VcsConfig)
			repo.VcsConfigMessage = (*config.SecretMessage)(&msg)
		}
	}

	if repoConfig.AutoGeneratedFiles != "" {
		var files []string
		if err := json.Unmarshal([]byte(repoConfig.AutoGeneratedFiles), &files); err == nil {
			repo.AutoGeneratedFiles = files
		}
	}

	s, err := searcher.New(AppConfig.DbPath, name, repo)
	if err != nil {
		return nil, err
	}

	AddSearcher(name, s)
	return s, nil
}
