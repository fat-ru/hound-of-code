package data

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"time"
)

// CreateRepoConfig creates a new repository configuration
func CreateRepoConfig(config *RepoConfig) (*RepoConfig, error) {
	result, err := db.Exec(`
		INSERT INTO repo_configs (
			name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`,
		config.Name, config.URL, config.Branch, config.VcsType,
		config.DisplayName, config.Enabled, config.MsBetweenPolls,
		config.VcsConfig, config.ExcludeDotFiles, config.EnablePollUpdates,
		config.EnablePushUpdates, config.AutoGeneratedFiles,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create repo config: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return GetRepoConfigByID(id)
}

// GetRepoConfigByID retrieves a repository configuration by ID
func GetRepoConfigByID(id int64) (*RepoConfig, error) {
	config := &RepoConfig{}
	err := db.QueryRow(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files,
			created_at, updated_at
		FROM repo_configs WHERE id = ?
	`, id).Scan(
		&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
		&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
		&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
		&config.EnablePushUpdates, &config.AutoGeneratedFiles,
		&config.CreatedAt, &config.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get repo config by id: %w", err)
	}
	return config, nil
}

// GetRepoConfigByName retrieves a repository configuration by name
func GetRepoConfigByName(name string) (*RepoConfig, error) {
	config := &RepoConfig{}
	err := db.QueryRow(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files,
			created_at, updated_at
		FROM repo_configs WHERE name = ?
	`, name).Scan(
		&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
		&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
		&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
		&config.EnablePushUpdates, &config.AutoGeneratedFiles,
		&config.CreatedAt, &config.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get repo config by name: %w", err)
	}
	return config, nil
}

// GetAllRepoConfigs retrieves all repository configurations
func GetAllRepoConfigs() ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files,
			created_at, updated_at
		FROM repo_configs ORDER BY id ASC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get all repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// GetEnabledRepoConfigs retrieves all enabled repository configurations
func GetEnabledRepoConfigs() ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files,
			created_at, updated_at
		FROM repo_configs WHERE enabled = 1 ORDER BY id ASC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get enabled repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// SearchRepoConfigs searches repository configurations by name or url
func SearchRepoConfigs(query string) ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files,
			created_at, updated_at
		FROM repo_configs
		WHERE name LIKE ? OR url LIKE ? OR display_name LIKE ?
		ORDER BY id ASC
	`, "%"+query+"%", "%"+query+"%", "%"+query+"%")
	if err != nil {
		return nil, fmt.Errorf("failed to search repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// UpdateRepoConfig updates a repository configuration
func UpdateRepoConfig(id int64, config *RepoConfig) (*RepoConfig, error) {
	now := time.Now()
	_, err := db.Exec(`
		UPDATE repo_configs SET
			name = ?, url = ?, branch = ?, vcs_type = ?, display_name = ?,
			enabled = ?, ms_between_polls = ?, vcs_config = ?,
			exclude_dot_files = ?, enable_poll_updates = ?,
			enable_push_updates = ?, auto_generated_files = ?, updated_at = ?
		WHERE id = ?
	`,
		config.Name, config.URL, config.Branch, config.VcsType,
		config.DisplayName, config.Enabled, config.MsBetweenPolls,
		config.VcsConfig, config.ExcludeDotFiles, config.EnablePollUpdates,
		config.EnablePushUpdates, config.AutoGeneratedFiles, now, id,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update repo config: %w", err)
	}
	return GetRepoConfigByID(id)
}

// DeleteRepoConfig deletes a repository configuration by ID
func DeleteRepoConfig(id int64) error {
	result, err := db.Exec("DELETE FROM repo_configs WHERE id = ?", id)
	if err != nil {
		return fmt.Errorf("failed to delete repo config: %w", err)
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("repo config not found")
	}
	return nil
}

// RepoConfigCount returns the total number of repository configurations
func RepoConfigCount() (int, error) {
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM repo_configs").Scan(&count)
	return count, err
}

// ToConfigRepo converts RepoConfig to config.Repo
func (r *RepoConfig) ToConfigRepo() *map[string]interface{} {
	repo := map[string]interface{}{
		"url":      r.URL,
		"vcs":      r.VcsType,
		"enabled":  r.Enabled,
	}
	if r.DisplayName != "" {
		repo["display-name"] = r.DisplayName
	}
	if r.Branch != "main" {
		// Note: Branch is not directly supported in the original config
		// but can be handled in the VCS layer
	}
	if r.MsBetweenPolls != 30000 {
		repo["ms-between-poll"] = r.MsBetweenPolls
	}
	if r.ExcludeDotFiles {
		repo["exclude-dot-files"] = true
	}
	if r.EnablePollUpdates {
		repo["enable-poll-updates"] = true
	}
	if !r.EnablePushUpdates {
		repo["enable-push-updates"] = false
	}
	if r.VcsConfig != "" {
		repo["vcs-config"] = json.RawMessage(r.VcsConfig)
	}
	if r.AutoGeneratedFiles != "" {
		var files []string
		if err := json.Unmarshal([]byte(r.AutoGeneratedFiles), &files); err == nil {
			repo["auto-generated-files"] = files
		}
	}
	return &repo
}
