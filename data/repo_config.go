package data

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"github.com/hound-search/hound/config"
)

// CreateRepoConfig creates a new repository configuration
func CreateRepoConfig(config *RepoConfig, userID int64) (*RepoConfig, error) {
	result, err := db.Exec(`
		INSERT INTO repo_configs (
			name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
	`,
		config.Name, config.URL, config.Branch, config.VcsType,
		config.DisplayName, config.Enabled, config.MsBetweenPolls,
		config.VcsConfig, config.ExcludeDotFiles, config.EnablePollUpdates,
		config.EnablePushUpdates, config.AutoGeneratedFiles, userID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create repo config: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return GetRepoConfigByID(id)
}

// GetRepoConfigByID retrieves a repository configuration by ID
func GetRepoConfigByID(id int64) (*RepoConfig, error) {
	config := &RepoConfig{}
	err := db.QueryRow(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs WHERE id = ?
	`, id).Scan(
		&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
		&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
		&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
		&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
		&config.CreatedAt, &config.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get repo config by id: %w", err)
	}
	return config, nil
}

// GetRepoConfigByName retrieves a repository configuration by name
func GetRepoConfigByName(name string) (*RepoConfig, error) {
	config := &RepoConfig{}
	err := db.QueryRow(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs WHERE name = ?
	`, name).Scan(
		&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
		&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
		&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
		&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
		&config.CreatedAt, &config.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get repo config by name: %w", err)
	}
	return config, nil
}

// GetAllRepoConfigs retrieves all repository configurations
func GetAllRepoConfigs() ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs ORDER BY id ASC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get all repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// GetEnabledRepoConfigs retrieves all enabled repository configurations
func GetEnabledRepoConfigs() ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs WHERE enabled = 1 ORDER BY id ASC
	`)
	if err != nil {
		return nil, fmt.Errorf("failed to get enabled repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// SearchRepoConfigs searches repository configurations by name or url
func SearchRepoConfigs(query string) ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs
		WHERE name LIKE ? OR url LIKE ? OR display_name LIKE ?
		ORDER BY id ASC
	`, "%"+query+"%", "%"+query+"%", "%"+query+"%")
	if err != nil {
		return nil, fmt.Errorf("failed to search repo configs: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// UpdateRepoConfig updates a repository configuration
func UpdateRepoConfig(id int64, config *RepoConfig) (*RepoConfig, error) {
	now := time.Now()
	_, err := db.Exec(`
		UPDATE repo_configs SET
			name = ?, url = ?, branch = ?, vcs_type = ?, display_name = ?,
			enabled = ?, ms_between_polls = ?, vcs_config = ?,
			exclude_dot_files = ?, enable_poll_updates = ?,
			enable_push_updates = ?, auto_generated_files = ?, updated_at = ?
		WHERE id = ?
	`,
		config.Name, config.URL, config.Branch, config.VcsType,
		config.DisplayName, config.Enabled, config.MsBetweenPolls,
		config.VcsConfig, config.ExcludeDotFiles, config.EnablePollUpdates,
		config.EnablePushUpdates, config.AutoGeneratedFiles, now, id,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update repo config: %w", err)
	}
	return GetRepoConfigByID(id)
}

// DeleteRepoConfig deletes a repository configuration by ID
func DeleteRepoConfig(id int64) error {
	result, err := db.Exec("DELETE FROM repo_configs WHERE id = ?", id)
	if err != nil {
		return fmt.Errorf("failed to delete repo config: %w", err)
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return fmt.Errorf("repo config not found")
	}
	return nil
}

// RepoConfigCount returns the total number of repository configurations
func RepoConfigCount() (int, error) {
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM repo_configs").Scan(&count)
	return count, err
}

// ToConfigRepo converts RepoConfig to config.Repo
func (r *RepoConfig) ToConfigRepo() *map[string]interface{} {
	repo := map[string]interface{}{
		"url":      r.URL,
		"vcs":      r.VcsType,
		"enabled":  r.Enabled,
	}
	if r.DisplayName != "" {
		repo["display-name"] = r.DisplayName
	}
	if r.Branch != "main" {
		// Note: Branch is not directly supported in the original config
		// but can be handled in the VCS layer
	}
	if r.MsBetweenPolls != 30000 {
		repo["ms-between-poll"] = r.MsBetweenPolls
	}
	if r.ExcludeDotFiles {
		repo["exclude-dot-files"] = true
	}
	if r.EnablePollUpdates {
		repo["enable-poll-updates"] = true
	}
	if !r.EnablePushUpdates {
		repo["enable-push-updates"] = false
	}
	if r.VcsConfig != "" {
		repo["vcs-config"] = json.RawMessage(r.VcsConfig)
	}
	if r.AutoGeneratedFiles != "" {
		var files []string
		if err := json.Unmarshal([]byte(r.AutoGeneratedFiles), &files); err == nil {
			repo["auto-generated-files"] = files
		}
	}
	return &repo
}

// GetRepoConfigsByUserID retrieves all repository configurations for a specific user
func GetRepoConfigsByUserID(userID int64) ([]*RepoConfig, error) {
	rows, err := db.Query(`
		SELECT id, name, url, branch, vcs_type, display_name, enabled,
			ms_between_polls, vcs_config, exclude_dot_files,
			enable_poll_updates, enable_push_updates, auto_generated_files, user_id,
			created_at, updated_at
		FROM repo_configs WHERE user_id = ? ORDER BY id ASC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get repo configs by user id: %w", err)
	}
	defer rows.Close()

	var configs []*RepoConfig
	for rows.Next() {
		config := &RepoConfig{}
		if err := rows.Scan(
			&config.ID, &config.Name, &config.URL, &config.Branch, &config.VcsType,
			&config.DisplayName, &config.Enabled, &config.MsBetweenPolls,
			&config.VcsConfig, &config.ExcludeDotFiles, &config.EnablePollUpdates,
			&config.EnablePushUpdates, &config.AutoGeneratedFiles, &config.UserID,
			&config.CreatedAt, &config.UpdatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan repo config: %w", err)
		}
		configs = append(configs, config)
	}
	return configs, nil
}

// ImportConfigRepos imports repos from config file into database
// Repos from config.json are imported with user_id=0 (historical repos)
func ImportConfigRepos(cfgRepos map[string]*config.Repo) error {
	for name, cfgRepo := range cfgRepos {
		// Check if repo already exists in database
		existing, err := GetRepoConfigByName(name)
		if err != nil {
			return fmt.Errorf("failed to check existing repo %s: %w", name, err)
		}
		if existing != nil {
			// Repo already exists, skip
			continue
		}

		// Build auto-generated files JSON string
		var autoGenFiles string
		if len(cfgRepo.AutoGeneratedFiles) > 0 {
			b, err := json.Marshal(cfgRepo.AutoGeneratedFiles)
			if err == nil {
				autoGenFiles = string(b)
			}
		}

		// Build vcs-config JSON string
		var vcsConfig string
		if cfgRepo.VcsConfig() != nil {
			vcsConfig = string(cfgRepo.VcsConfig())
		}

		// Import with user_id=0 for historical repos
		_, err = db.Exec(`
			INSERT INTO repo_configs (
				name, url, branch, vcs_type, display_name, enabled,
				ms_between_polls, vcs_config, exclude_dot_files,
				enable_poll_updates, enable_push_updates, auto_generated_files, user_id
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			name, cfgRepo.Url, "main", cfgRepo.Vcs,
			cfgRepo.DisplayName, 1, cfgRepo.MsBetweenPolls,
			vcsConfig, cfgRepo.ExcludeDotFiles,
			cfgRepo.PollUpdatesEnabled(), cfgRepo.PushUpdatesEnabled(),
			autoGenFiles, 0,
		)
		if err != nil {
			return fmt.Errorf("failed to import repo %s: %w", name, err)
		}
	}
	return nil
}
